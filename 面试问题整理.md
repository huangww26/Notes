# 面试问题整



## 1. C++部分

### static 关键字的用法

​	static可以用来修饰局部变量，全局变量以及函数。

#### 修饰局部变量

​	一般情况下，对于局部变量是存放在栈区的，但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

#### 修饰全局变量

​	static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。

#### 修饰函数

​	用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

#### 在类中

​	若在类中用static修饰某个变量或函数，则表示该成员与类关联，而非与类的每个对象关联。

​	**类的静态数据成员的初始化：1）const静态成员可直接在类内初始化，非const一般要在类实现文件中初始化。2）用静态方法初始化。3）用内部类初始化。**



### extern关键字

​	在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

​	在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数，**指明按照C语言的方式编译和链接**。



### 控制内存分配

#### new表达式执行步骤：

1. 调用一个名为**operator new**（或者**operator new []**）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。
2. 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。
3. 对象被分配了空间并构造完成，返回一个指向该对象的指针。

#### delete表达式执行步骤：

1. 对指针所指的对象或者对象数组中的元素执行对应的析构函数。
2. 编译器调用名为**operator delete**（或者**operator delete []**）的标准库函数释放内存空间。

#### operator new接口和operator delete接口

```c++
// 可能抛出异常
void *operator new(size_t);
void *operator new[](size_t);
void operator delete(void *) noexcept;
void operator delete[](void *) noexcept;

// 承诺不抛出异常
void *operator new(size_t, nothrow_t &) noexcept;
void *operator new[](size_t, nothrow_t &) noexcept;
void operator delete(void *, nothrow_t &) noexcept;
void operator delete[](void *, nothrow_t &) noexcept;
```

​	下面的函数不能被用户重载：

```C++
void *operator new(size_t, void *);
```

#### new/delete和malloc/free的区别

1. new/delete是C++的运算符，而malloc/free是C/C++的标准库函数。
2. new 内置了sizeof、类型转换和类型安全检查功能，new是类型安全的。malloc需要手动计算字节数，返回结果需要显示转型，并且不是类型安全的。
3. 对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。malloc不调用构造函数，free不调用析构函数。

 ​使用malloc时，在C中会自动提升`void *`：

```c++
int *pi = malloc(sizeof *pi);
```

但在C++中必须显示转型：

```c++
int *pi = static_cast<int *>malloc(sizeof *pi);
```



#### C++保留malloc/free的原因

​	C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放new创建的动态对象，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放malloc申请的动态内存，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。



### 堆与栈

|        |                    栈                     |                    堆                     |
| ------ | :--------------------------------------: | :--------------------------------------: |
| 管理方式   |                 由编译器自动管理                 |             堆空间的申请和释放由程序员控制              |
| 空间大小   | 栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和最大容量是系统预先规定的，当申请空间超过栈的剩余容量时，将提示溢出。 | 堆是向高地址扩展的数据结构，是不连续的内存区域。系统用链表来存储空闲内存的地址，且链表的遍历方向由低地址向高地址。 |
| 是否产生碎片 |                    不会                    |           频繁调用malloc/free会产生碎片           |
| 分配方式   |       由编译器完成，编译器使用`alloca()`进行动态分配       |         使用malloc/free或new/delete         |
| 分配效率   |           有专门的地址寄存器，压栈出栈有专门的指令           | 堆是C函数库提供的，实现机制比较复杂。分配一个块时，用一定算法在堆内存中搜寻可用的空间，若没找到则需要对内存进行整理。效率比栈低得多。 |

​                           ![20140904220124724](C:\Users\hweiwei\Desktop\20140904220124724.png)



### 类型转换

#### static_cast

#### const_cast

#### dynamic_cast

#### reinterpret_cast



### 继承和组合

#### 继承的优点：

1. 容易进行新的实现，因为其大多数可继承而来。
2. 易于修改或扩展那些被复用的实现。

#### 继承的缺点

1. 破坏了封装性，因为这会将父类的实现细节暴露给子类。
2. “白盒”复用，因为父类的内部细节对于子类而言通常是可见的。
3. 当父类的实现更改时，子类也不得不会随之更改。
4. 从父类继承来的实现将不能在运行期间进行改变。

#### 组合的优点

1. 封装性好。
2. 实现上的相互依赖性比较小。
3. 每一个类只专注于一项任务。
4. 可以在运行期间动态地定义（对象的）组合。



### 菱形继承（钻石问题）

​	会产生二义性问题。



### 智能指针



### C++多态的实现原理

​	当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储类成员函数指针的数据结构，虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针(__vptr指针，定义为void**类型)。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表，从而在调用虚函数时，就能够找到正确的函数。

- C++是在构造函数中进行虚函数表的创建和虚表指针	额初始化的



## 2. 操作系统

### 进程和线程

​	两者之间的区别：

- 从概念上讲：进程是一个程序对一个数据集的动态执行过程，是分配资源的基本单位；线程是进程内的基本调度单位，线程的划分尺度小于进程，一个进程包含一个或多个线程。

- 从执行过程中来看：进程拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。线程又叫做轻量级进程，线程间的切换代价小于进程间的切换代价。线程不能独立运行，必须依存于进程中。

- 从逻辑角度看：多线程的意义在于一个应用程序中有多个执行部分可以同时执行，但是，操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理及资源分配。

  引入线程的好处：

- 易于调度

- 提高并发性

- 开销小

- 有利于发挥多处理器的功能




### 线程同步

​	线程间通信方式主要有：临界区、互斥量、信号量、事件。

1. **临界区** 。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。 仅能在同一进程内使用。
2. **互斥量**。互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。
3. **信号量**。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。
4. **事件**。事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。

### 进程间通信（IPC）

#### 管道（pipe）

​	管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

#### 命名管道（FIFO）

​	有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

#### 信号

​	信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

#### 消息队列

​	消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

#### 共享内存

​	共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

#### 信号量

​	信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

#### 套接字（socket）

​	套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。




### 分页和分段

​	分页管理是从计算机的角度考虑设计的，以提供内存的利用率和提升计算机性能，且分页通过硬件机制实现，对用户完全透明。而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

​	在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成。

​	页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位。

 ![1-140F102004L08](C:\Users\hweiwei\Desktop\1-140F102004L08.jpg)

### 虚拟内存

​	虚拟内存是计算机系统最重要的概念之一。为了更加有效地管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存，它为每一个进程提供了一个大的、一致的和私有的地址空间。虚拟内存提供了三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保护活动区域，并根据需要在磁盘和驻存之间来回传送数据，通过这种方式，它高效地使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏。

#### 简化内存管理

​	VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。

1. 简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。
2. 简化加载。虚拟内存还使得容易向内存加载可执行文件和共享对象文件。
3. 简化共享。通过讲不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的副本。
4. 简化内存分配。当用户程序要求额外的堆空间使，操作系统分配一个适当数字（例如$k$）个连续的虚拟内存页面，并且将它们映射到物理内存中任意的$k$个物理页面。



### 同步/异步、阻塞/非阻塞

- 同步I/O操作：导致请求进程阻塞，知道I/O完成；

- 异步I/O操作：不导致请求阻塞。

  ​同步和异步关注的是**消息通信机制**：所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

  阻塞和非阻塞关注的是程序在**等待调用结果（消息，返回值）时的状态**：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

  ​


### I/O多路复用

​	I/O多路复用就是通过一种机制（select，poll，epoll），一个进程可以监听多个描述符，一旦某个描述符就绪，能够通知程序进行相应的读写操作。

#### select

````C++
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval 				*timeout);
````

#### poll

```C++
int poll(struct pollfd *fds, unsigned int nfds, int timeout);

struct pollfd {
  int fd;
  short events;
  short revents;
};
```

​	**select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。**

#### epoll

​	相对于select和poll来说，epoll更加灵活，没有描述符数量的限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

​	epoll操作过程需要三个接口，分别如下：

```C++
int epoll_create(int size); // 创建一个epoll句柄，size不是限制了所能监听的描述符的个数，只
						    // 是对内核初始分配数据结构的一个建议

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// op: EPOLL_CTL_ADD, EPOLL_CTL_DEL, EPOLL_CTL_MOD
struct epoll_event {
  __uint32_t events;
  epoll_data_t data;
};
/*events可以是以下几个宏的集合：
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来           说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再	             次把这个socket加入到EPOLL队列里
*/
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```



#### epoll相比select/poll的优势

- 支持一个进程打开大数目的描述符（FD）

  > select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是1024。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于1024,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

- IO效率不随FD数目增加而线性下降

  > 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是"活跃"的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对"活跃"的socket进行操作---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有"活跃"的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个"伪"AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的---比如一个高速LAN环境，epoll并不比select/poll有什么效率，相反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。

- 使用mmap加速内核与用户空间的消息传递

  > 这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核与用户空间mmap同一块内存实现的。


#### epoll为什么高效？

- select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用（这意味着每次调用都要将fd列表从用户态拷贝到内核态，当fd数目很多时，这会造成低效）。而每次调用epoll_wait时（作用相当于调用select/poll），不需要再传递fd列表给内核，因为已经在epoll_ctl中将需要监控的fd告诉了内核（epoll_ctl不需要每次都拷贝所有的fd，只需要进行增量式操作）。所以，在调用epoll_create之后，内核已经在内核态开始准备数据结构存放要监控的fd了。每次epoll_ctl只是对这个数据结构进行简单的维护。
- 此外，内核使用了**slab机制**，为epoll提供了快速的数据结构。在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控的fd。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的fd，这些fd会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。
- epoll的第三个优势在于：当我们调用epoll_ctl往里塞入百万个fd时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的fd给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。而且，通常情况下即使我们要监控百万计的fd，大多一次也只返回很少量的准备就绪fd而已，所以，epoll_wait仅需要从内核态copy少量的fd到用户态而已。那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把fd放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个fd的中断到了，就把它放到准备就绪list链表里。所以，当一个fd（例如socket）上有数据到了，内核在把设备（例如网卡）上的数据copy到内核中后就来把fd（socket）插入到准备就绪list链表里了。


1. **执行epoll_create时，创建了红黑树和就绪list链表。**
2. **执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。**
3. **执行epoll_wait时立刻返回准备就绪链表里的数据即可。**




### 池化技术

​	池化技术主要有线程池，内存池，连接池，对象池等等

#### 线程池

​	其实线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。



## 3. 项目

### 项目介绍

​	项目的研究目的：一方面程序化交易在国内才刚刚起步，是比较新的东西，因此有很多可以挖掘的地方。另一方面是借此机会可以提供代码能力，项目用的是Python语言，GUI开发是基于PyQt，数据处理用到了numpy扩展库，数据库用的是MongoDB。

​	程序化交易核心部分是策略的研究，

### 事件驱动

### GUI

###问题及解决办法



## 4. 数据库

### 数据库事务	

​	数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。通俗地讲，事务是一组原子性的 SQL 查询，事务内的操作要么完全执行，要么这些操作全不执行，不存在中间状态。事务由 *begin transaction* 和 *end transaction* 之间执行的全体操作组成，这些步骤集合必须作为一个单一的、不可分割的单元出现。

#### ACID

​	一般说到事务，就会想到它的特性：ACID，下面结合一个现实中的银行转账例子来说明：A B两同学在同一家银行ZSBANK的账号都有 1,000 块钱，A通过ZSBANK银行向B转了100块钱，这个事务分为两个操作，即从A账号扣100和向B同学账号增加100。那么：

- 原子性（Atomicity）：事务中所有操作要么全部提交成功，要么全部失败回滚。对事务来说，不可能只执行其中的一部分。也就是说上面例子中不可能出现扣除了A的钱，但没增加B的钱的情况。
- 一致性（Consistency）：数据库总是从一个一致的状态转换到另一个一致的状态。**一致性指的是语义上的一致性，即业务逻辑层面的一致。**也就是说A、B两人在转账钱的总和是2,000，转账后两人的总和也必须是 2,000。不会因为这次转账事务破坏这个状态。如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。
- 隔离性（Isolation）：一个事务所做的修改在最终提交之前，对其它事务是不可见的。因此，每个事务都感觉不到系统中有其它事务在并发地执行。也就是说如果A转出100但事务没有确认提交，这时候银行人员对其账号查询时，看到的应该还是1,000，而不是900。
- 持久性（Durability）：一旦事务提交，其所做的修改就会永久保存到数据库中。此时，即使系统崩溃，修改的数据也不会丢失。也就是说转账一但完成，那么A余额为900，B为1,100，这个结果将永远保存在银行的数据库中，直到他们下次交易事务的发生。


​	在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。MySQL数据库innodb的事务，是通过**redo log（innodb log)，undo log，锁机制来维护一致性的**。

#### 隔离级别

| 隔离级别 |  脏读  | 不可重复读 |  幻读  |
| :--: | :--: | :---: | :--: |
| 读未提交 |  Y   |   Y   |  Y   |
| 读已提交 |  N   |   Y   |  Y   |
| 可重复读 |  N   |   N   |  Y   |
| 串行化  |  N   |   N   |  N   |

1. 读取未提交的内容：事务在读取数据的时候并未对数据加锁。在修改数据的时候只对数据增加行级共享锁（其他事务可以读取但是不可以更新）。因此，事务在读取数据的时候会读取到其他事务未提交的数据产生脏读。
2. 读取提交内容：事务对当前被读取的数据加行级共享锁，一旦读完该行就立即释放该锁；事务在更新某数据的瞬间，必须先对数据增加行级排他锁（其他事务不可以对该数据进行任何操作），直到事务结束才释放。因此，事务在修改的过程中由于事务没有提交所以不会影响到其他事务，避免了脏读的发生。但是会出现不可重复读的情况。
3. 可重复读：事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放；事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。因此，事务在读取数据的时候其他事务是可以对该数据进行读取操作，因此避免了不可重复读的情况。但是无法避免幻读的发生。
4. 可串行化：事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放；事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放。因此，事务A在查询数据的时候就对该表增加了表级共享锁，其他事务只可以对该表进行查询操作直到事务A提交。所以避免了幻读的产生。



### MyISAM 和 InnoDB的比较

- MyISAM不支持事务，InnoDB支持事务
- MyISAM适合以查询和插入为主的应用，InnoDB适合频繁修改和设计安全性较高的应用
- MyISAM不支持外键，InnoDB支持外键
- MyISAM保存表的行数，InnoDB不保存表的行数
- MyISAM只支持表锁，InnoDB支持行锁
- 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表
- 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引



## 5. Python

### 闭包

#### 什么是闭包？

​	如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包。

#### 闭包的作用

​	类似于类，闭包提供了一种函数粒度的抽象。

1. 对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。
2. 闭包有效地减少了函数参数的数目，这对并行计算非常有价值。












​	
